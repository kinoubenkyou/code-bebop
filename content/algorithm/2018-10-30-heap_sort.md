Tags: Python

The idea of heap sort is first turning the list into a heap, then swapping the root with the last leaf to prepend the sorted side, as well as sifting down the new root to maintain the heap condition. The sort repeats the swapping and sifting until the heap is empty.

\- Space Complexity of O(1):

The sort is in-place, which means only swapping elements in the list.

\- Non-stability:

When swapping the leaf or sifting down the new root, the element's order relative to its other equal elements is broken.

\- Worst-case Time Complexity of O(nlogn) Comparison and O(nlogn) Swapping:

The sort always has n loops of building the sorted side. The case happens when each loop has the new root sifts down to the last leaf, and thus has 3logn comparisons as well as logn swappings.

\- Implementation in Python:

```python
def swap(elements, index_1, index_2):
    elements[index_1], elements[index_2] = elements[index_2], elements[index_1]

def sift_down(elements, index=0, end_index=None):
    if end_index is None:
        end_index = len(elements)

    while True:
        left_i = index * 2 + 1
        right_i = index * 2 + 2

        if (right_i < end_index and
                elements[right_i] > elements[left_i] and
                elements[index] < elements[right_i]):
            swap(elements, index, right_i)
            index = right_i
        elif left_i < end_index:
            if elements[index] < elements[left_i]:
                swap(elements, index, left_i)
                index = left_i
            else:
                break
        else:
            break

def heapify(elements):
    for i in reversed(range(len(elements) // 2)):
        sift_down(elements, i)

def heap_sort(elements):
    heapify(elements)

    # loops of building the sorted side
    for i in reversed(range(len(elements))):
        swap(elements, 0, i)
        sift_down(elements, 0, i)
```
